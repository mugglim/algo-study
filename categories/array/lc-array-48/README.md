## 링크
https://leetcode.com/problems/rotate-image/

## 풀이 1

> DO NOT allocate another 2D matrix and do the rotation.

즉, 연산을 통해 기존의 배열의 값을 90도 회전시켜야 한다.
규칙이 잘 보이지 않아서, 예제에서 주어진 n이 3인 경우와 4인 경우를 회전 시켜 보면서 규칙을 찾았다.

- 예제 1(n=3)

| before | after  |  diff_y  | diff_x |
|:------:|:------:|:--------:|:------:|
| (0,0)  | (0,2)  |    0     |   +2   |
| (0,1)  | (1,2)  |    +1    |   +1   |
| (0,2)  | (2,2)  |    +2    |   0    |
| (1,0)  | (0,1)  |    -1    |   +1   |
| (1,1)  | (1,1)  |    0     |   0    |
| (1,2)  | (2,1)  |    +1    |   -1   |
| (2,0)  | (0,0)  |    -2    |   0    |
| (2,1)  | (1,0)  |    -1    |   -1   |
| (2,2)  | (2,0)  |    0     |   -2   |

- 예제 2(n=4)

| before | after | diff_y | diff_x |
|:------:|:-----:|:------:|:------:|
| (0,0)  | (0,3) |   0    |   +3   |
| (0,1)  | (1,3) |   +1   |   +2   |
| (0,2)  | (2,3) |   +2   |   +1   |
| (0,3)  | (3,3) |   +3   |   0    |
| (1,0)  | (0,2) |   -1   |   +2   |
| (1,1)  | (1,2) |   0    |   +1   |
| (1,2)  | (2,2) |   +1   |   0    |
| (1,3)  | (3,2) |   +2   |   -1   |
| (2,0)  | (0,1) |   -2   |   +1   |
| (2,1)  | (1,1) |   -1   |   0    |
| (2,2)  | (2,1) |   0    |   -1   |
| (2,3)  | (3,1) |   +1   |   -2   |
| (3,0)  | (0,0) |   -3   |   0    |
| (3,1)  | (1,0) |   -2   |   -1   |
| (3,2)  | (2,0) |   -1   |   -2   |
| (3,3)  | (3,0) |   0    |   -3   |

두 예제를 통해 아래의 규칙을 알 수 있었다.
- diff_y : x-y
- diff_x : n-1 - (y+x)
- 좌표 별로 회전의 수는 4번이다.
```text
[
    [5,1,9,11],
    [2,4,8,10],
    [13,3,6,7],
    [15,14,12,16]
]


1) 5->11->16->15
2) 1->10->12->13
3) 9->7->14->2
4) 4->8->6->3

```

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        n = len(matrix)

        for y in range(n//2 + 1):
            for x in range(y, n-y-1):
                prev = matrix[y][x]
                curr = [y,x, prev]
                for _ in range(4):
                    # 1) 다음 좌표를 계산한다.
                    dy,dx = curr[1] - curr[0], n -1 - (curr[0] + curr[1])
                    ny,nx = curr[0] + dy, curr[1] + dx

                    # 2) 다음 좌표에 있는 값을 저장한다.
                    prev = matrix[ny][nx]

                    # 3) swap 한다.
                    matrix[ny][nx] = curr[-1]

                    # 4) 다음 좌표를 반영한다.
                    curr = [ny,nx, prev]
```

메모리는 `60%` 적게 사용 했지만, 실행시간은 `20%` 밖에 빠르지 않다. 이후에 실행시간을 개선해봐야겠다.
```text
Runtime: 40 ms, faster than 19.44% 
Memory Usage: 14.3 MB, less than 60.87%
```

## 결과
|풀이|     방식     |시간|
|:---:|:----------:|:--------:|
|1| 규칙을 통한 계산  |40 ms| 